# Java并发编程学习笔记

### 目的

提高程序的性能，包括处理吞吐率，响应性，提高硬件的使用效率。

### 宏观

并发编程可分为分工，同步，互斥

### 存在的问题

- 线程安全 （原子性，有序性， 可见性）
- 竞条（条件竞态，数据竞态）
- 上下文切换
- 线程活性问题(死锁，锁死， 活锁， 饥饿)
- 资源争用和调度(公平调度， 非公司调度)

### 锁

#### 作用

能够保护共享数据以实现线程安全，包括保障原子性，可见性和有序性， 从宏观上将多个线程的并发访问改为了串行，会降低系统性能. 

#### 分类

内部锁synchronized, 显示锁Lock,悲观读写锁(ReadWriteLock),乐观读写锁(StampedLock)

#### 特征

可重入性， 粒度

#### 使用

关键要分析清楚锁和资源的关系，使用合适的锁粒度

如果资源之间没有关系，很好处理，每个资源一把锁就可以了。如果资源之间有关联关系，就要选择一个粒度更大的锁，这个锁应该能够覆盖所有相关的资源。除此之外，还要梳理出有哪些访问路径，所有的访问路径都要设置合适的锁，这个过程可以类比一下门票管理。

#### 问题

锁的争用与调度(公平与非公平), 上下文切换，活性故障

#### 原则

锁，应是私有的、不可变的、不可重用的。

### Volatile

语义是声明字段是易变不稳定的。表示被修饰的变量值容易发生变化，因而不稳定。保证可见性和有序性。原子性方面仅保障volatile变理操作的原子性,但没有锁的排它性, 保障long/double变量的读写操作原子性

#### 使用场景

- 作为状态变量
- 使用volatile保障可见性
- 使用volatile代替锁  创建一个新的对象并将该对象引用赋值给相应的引用变量
- 使用volatile实现简易读写锁

### 对象初始化

static 能保证线程初次读取到一个类的静态变量的是初始值而不是默认值

final 能保证其修饰的字段都是初始化完毕的

### 多线程

多线程编程将程序中只能串行的部分与可以并发的部分区分开来，使用专门的线程去并发地执行那些可并发化的部分。具体来说有两种方式:基于数据的分割和基于任务的分割。

#### 基于数据的分割

将原始输入的数据按照一定的规则分解为若干规模较小的子输入，使用工作者线程来对这些子输入进行处理，从而实现对输入数据的并发处理。

#### 基于任务的分割

将原始任务处理逻辑分解为若干子任务，并创建专门的工作者线程来执行这些子任务

#### 提速比

Amdahl定律可以得到程序多线程最大提速比

#### 线程数量设置原则

对于CPU密集型任务可将线程数设置为Ncpu + 1

对于IO密集型任务可将优先考虑将线程数设置为1，在一个线程不够情况下向2*Ncpu靠近

设置公式   Nthreads = Ncpu * Ucpu * (1 + WT/ST)

### 线程间协作

#### wait/notify

```java
//调用wait方法前获得相应的内部锁
synchronized(someObject){
	while(保护条件不成立){
		someObject.wait();
	}
	doAction();
}

//调用notify方法
synchronized(someObject){
	updateSharedState();
	someObject.notify();
}

//wait实现伪代码
public void wait(){
	if(!Thread.holdsLock(this)){
		throws new IllegalMonitorStateException();
	}
	if (当前对象不在等待集中){
		addToWaitSet(Thread.currentThread());
	}
	
	atomic {
		releaseLock(this);
		block(Thread.currentThread());
	}
	
	acquireLock(this);
	removeFromWaitSet(Thread.currentThread());
}
```

存在的问题 

- 过早唤醒问题 
- 信号丢失问题
- 欺骗性唤醒问题
- 上下文切换问题

#### CountDownLatch

倒计时器协调，一次性

#### CycicBarrier

同步参与线程在同一时刻开始工作

#### 生产者与消费者

##### BlockingQueue

- ArrayBlockingQueue是有界队列，内部使用一个数组作为其存储空间，而数组空间是预先分配的，因此并不会增加GC负担，其缺点是内部在实现put和take操作的时候使用同一个锁，适用于生产者与消费者并发程度较低的情况
- LinkedBlockingQueue即能实现无界队列也能实现有界队列，其内部实现put,take操作的时候分别使用了两个显式锁，内部存储空间是一个链表，所需存储空间是动态分配的，缺点可能会增加GC负担，适合在生产者和消费者线程并发程度较大的时候
- SynchronousQueu是一个种特殊有界队列，适用于生产者与消费者速率相当的情况

##### PipedOutputStream/PipedInputStream

适合在单生产者-单消费者使用的情形

#### Semaphore

允许多个进程同时访问特定资源， 起来一个"限流"的作用

#### Exchanger

交换两个线程缓冲区

