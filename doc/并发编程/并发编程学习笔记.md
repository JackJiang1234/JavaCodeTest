# Java并发编程学习笔记

### 目的

提高程序的性能，包括处理吞吐率，响应性，提高硬件的使用效率。

### 宏观

并发编程可分为分工，同步，互斥

### 存在的问题

- 线程安全 （原子性，有序性， 可见性）
- 竞条（条件竞态，数据竞态）
- 上下文切换
- 线程活性问题(死锁，锁死， 活锁， 饥饿)
- 资源争用和调度(公平调度， 非公司调度)

### 锁

#### 作用

能够保护共享数据以实现线程安全，包括保障原子性，可见性和有序性， 从宏观上将多个线程的并发访问改为了串行，会降低系统性能. 

#### 分类

内部锁synchronized, 显示锁Lock,悲观读写锁(ReadWriteLock),乐观读写锁(StampedLock)

#### 特征

可重入性， 粒度

#### 使用

关键要分析清楚锁和资源的关系，使用合适的锁粒度

如果资源之间没有关系，很好处理，每个资源一把锁就可以了。如果资源之间有关联关系，就要选择一个粒度更大的锁，这个锁应该能够覆盖所有相关的资源。除此之外，还要梳理出有哪些访问路径，所有的访问路径都要设置合适的锁，这个过程可以类比一下门票管理。

#### 问题

锁的争用与调度(公平与非公平), 上下文切换，活性故障

#### 原则

锁，应是私有的、不可变的、不可重用的。

### Volatile

语义是声明字段是易变不稳定的。表示被修饰的变量值容易发生变化，因而不稳定。保证可见性和有序性。原子性方面仅保障volatile变理操作的原子性,但没有锁的排它性, 保障long/double变量的读写操作原子性

#### 使用场景

- 作为状态变量
- 使用volatile保障可见性
- 使用volatile代替锁  创建一个新的对象并将该对象引用赋值给相应的引用变量
- 使用volatile实现简易读写锁

### 对象初始化

static 能保证线程初次读取到一个类的静态变量的是初始值而不是默认值

final 能保证其修饰的字段都是初始化完毕的

### 多线程

多线程编程将程序中只能串行的部分与可以并发的部分区分开来，使用专门的线程去并发地执行那些可并发化的部分。具体来说有两种方式:基于数据的分割和基于任务的分割。

#### 基于数据的分割

将原始输入的数据按照一定的规则分解为若干规模较小的子输入，使用工作者线程来对这些子输入进行处理，从而实现对输入数据的并发处理。

#### 基于任务的分割

将原始任务处理逻辑分解为若干子任务，并创建专门的工作者线程来执行这些子任务

#### 提速比

Amdahl定律可以得到程序多线程最大提速比

#### 线程数量设置原则

对于CPU密集型任务可将线程数设置为Ncpu + 1

对于IO密集型任务可将优先考虑将线程数设置为1，在一个线程不够情况下向2*Ncpu靠近

设置公式   Nthreads = Ncpu * Ucpu * (1 + WT/ST)